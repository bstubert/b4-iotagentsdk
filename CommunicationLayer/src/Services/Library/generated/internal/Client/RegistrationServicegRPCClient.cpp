//********************************************************************************//
// MIT License                                                                    //
//                                                                                //
// Copyright (c) 2024 TeamViewer Germany GmbH                                     //
//                                                                                //
// Permission is hereby granted, free of charge, to any person obtaining a copy   //
// of this software and associated documentation files (the "Software"), to deal  //
// in the Software without restriction, including without limitation the rights   //
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell      //
// copies of the Software, and to permit persons to whom the Software is          //
// furnished to do so, subject to the following conditions:                       //
//                                                                                //
// The above copyright notice and this permission notice shall be included in all //
// copies or substantial portions of the Software.                                //
//                                                                                //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR     //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,       //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE    //
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER         //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,  //
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  //
// SOFTWARE.                                                                      //
//********************************************************************************//
// ==================================
// Generated by TVCMGen. DO NOT EDIT!
// ==================================

#include "RegistrationServicegRPCClient.h"

#include <TVRemoteScreenSDKCommunication/ServiceBase/ClientErrorMessage.h>
#include <TVRemoteScreenSDKCommunication/ServiceBase/RequestMetadata.h>

#include <grpc++/create_channel.h>

namespace TVRemoteScreenSDKCommunication
{

namespace RegistrationService
{

void RegistrationServicegRPCClient::StartClient(const std::string& destination)
{
	m_destination = destination;

	m_channel = ::grpc::CreateChannel(m_destination, ::grpc::InsecureChannelCredentials());
	m_stub = ::tvregistrationservice::RegistrationService::NewStub(m_channel);
}

void RegistrationServicegRPCClient::StopClient(bool /*force*/)
{
	m_stub.reset();
	m_channel.reset();
}

ServiceType RegistrationServicegRPCClient::GetServiceType() const
{
	return ServiceType::Registration;
}

const std::string& RegistrationServicegRPCClient::GetDestination() const
{
	return m_destination;
}

// rpc call ExchangeVersion
auto RegistrationServicegRPCClient::ExchangeVersion(const std::string& ownVersion) -> ExchangeVersionResponse
{
	ExchangeVersionResponse returnValue{};

	if (m_channel == nullptr || m_stub == nullptr)
	{
		returnValue.errorMessage = TvServiceBase::ErrorMessage_MissingStartClient;
		return returnValue;
	}

	// No input validation

	::grpc::ClientContext context{};

	std::string comId{};

	::tvregistrationservice::ExchangeVersionRequest request{};

	request.set_version(ownVersion);

	::tvregistrationservice::ExchangeVersionResponse response{};

	::grpc::Status status = m_stub->ExchangeVersion(&context, request, &response);

	if (status.ok())
	{
		returnValue.state = CallState::Ok;
		returnValue.versionNumber = response.version();
	}
	else
	{
		returnValue.errorMessage = status.error_message();
	}

	return returnValue;
}

// rpc call Discover
auto RegistrationServicegRPCClient::Discover(const std::string& comId) -> DiscoverResponse
{
	DiscoverResponse returnValue{};

	if (m_channel == nullptr || m_stub == nullptr)
	{
		returnValue.errorMessage = TvServiceBase::ErrorMessage_MissingStartClient;
		return returnValue;
	}

	if (comId.empty())
	{
		returnValue.errorMessage = TvServiceBase::ErrorMessage_InvalidInputParameter;
		return returnValue;
	}

	::grpc::ClientContext context{};

	context.AddMetadata(ServiceBase::CommunicationIdToken, comId);

	::tvregistrationservice::DiscoverRequest request{};

	request.set_communicationversion(comId);

	::tvregistrationservice::DiscoverResponse response{};

	::grpc::Status status = m_stub->Discover(&context, request, &response);

	if (status.ok())
	{
		returnValue.state = CallState::Ok;
		returnValue.communicationId = response.communicationid();

		std::vector<ServiceInformation> services;

		for (int serviceIndex = 0; serviceIndex < response.serviceinfo_size(); ++serviceIndex)
		{
			ServiceInformation serviceInformation;

			const ::tvregistrationservice::ServiceInformation& serviceInfo = response.serviceinfo(serviceIndex);
			serviceInformation.location = serviceInfo.location();

			const auto serviceType = serviceInfo.type();

			ServiceType serviceTypeEnumValue = ServiceType::Unknown;

			switch (serviceType)
			{
				case ::tvregistrationservice::ServiceType::Unknown:
					serviceTypeEnumValue = ServiceType::Unknown;
					break;
				case ::tvregistrationservice::ServiceType::Registration:
					serviceTypeEnumValue = ServiceType::Registration;
					break;
				case ::tvregistrationservice::ServiceType::Connectivity:
					serviceTypeEnumValue = ServiceType::Connectivity;
					break;
				case ::tvregistrationservice::ServiceType::Image:
					serviceTypeEnumValue = ServiceType::Image;
					break;
				case ::tvregistrationservice::ServiceType::Input:
					serviceTypeEnumValue = ServiceType::Input;
					break;
				case ::tvregistrationservice::ServiceType::SessionControl:
					serviceTypeEnumValue = ServiceType::SessionControl;
					break;
				case ::tvregistrationservice::ServiceType::SessionStatus:
					serviceTypeEnumValue = ServiceType::SessionStatus;
					break;
				case ::tvregistrationservice::ServiceType::ImageNotification:
					serviceTypeEnumValue = ServiceType::ImageNotification;
					break;
				case ::tvregistrationservice::ServiceType::AccessControlIn:
					serviceTypeEnumValue = ServiceType::AccessControlIn;
					break;
				case ::tvregistrationservice::ServiceType::AccessControlOut:
					serviceTypeEnumValue = ServiceType::AccessControlOut;
					break;
				case ::tvregistrationservice::ServiceType::InstantSupport:
					serviceTypeEnumValue = ServiceType::InstantSupport;
					break;
				case ::tvregistrationservice::ServiceType::ViewGeometry:
					serviceTypeEnumValue = ServiceType::ViewGeometry;
					break;
				case ::tvregistrationservice::ServiceType::InstantSupportNotification:
					serviceTypeEnumValue = ServiceType::InstantSupportNotification;
					break;
				case ::tvregistrationservice::ServiceType::ChatIn:
					serviceTypeEnumValue = ServiceType::ChatIn;
					break;
				case ::tvregistrationservice::ServiceType::ChatOut:
					serviceTypeEnumValue = ServiceType::ChatOut;
					break;
				case ::tvregistrationservice::ServiceType::ConnectionConfirmationRequest:
					serviceTypeEnumValue = ServiceType::ConnectionConfirmationRequest;
					break;
				case ::tvregistrationservice::ServiceType::ConnectionConfirmationResponse:
					serviceTypeEnumValue = ServiceType::ConnectionConfirmationResponse;
					break;
				default:

					break;
			}

			serviceInformation.type = serviceTypeEnumValue;

			services.push_back(std::move(serviceInformation));
		}

		returnValue.services.swap(services);
	}
	else
	{
		returnValue.errorMessage = status.error_message();
	}

	return returnValue;
}

// rpc call Register
auto RegistrationServicegRPCClient::Register(const std::string& comId, ServiceType type, const std::string& location) -> CallStatus
{
	CallStatus returnValue{};

	if (m_channel == nullptr || m_stub == nullptr)
	{
		returnValue.errorMessage = TvServiceBase::ErrorMessage_MissingStartClient;
		return returnValue;
	}

	if (location.empty())
	{
		returnValue.errorMessage = TvServiceBase::ErrorMessage_InvalidInputParameter;
		return returnValue;
	}

	::grpc::ClientContext context{};

	context.AddMetadata(ServiceBase::CommunicationIdToken, comId);

	::tvregistrationservice::RegisterRequest request{};

	::tvregistrationservice::ServiceType typeProtoValue = ::tvregistrationservice::ServiceType::Unknown;

	switch (type)
	{
		case ServiceType::Unknown:
			typeProtoValue = ::tvregistrationservice::ServiceType::Unknown;
			break;
		case ServiceType::Registration:
			typeProtoValue = ::tvregistrationservice::ServiceType::Registration;
			break;
		case ServiceType::Connectivity:
			typeProtoValue = ::tvregistrationservice::ServiceType::Connectivity;
			break;
		case ServiceType::Image:
			typeProtoValue = ::tvregistrationservice::ServiceType::Image;
			break;
		case ServiceType::Input:
			typeProtoValue = ::tvregistrationservice::ServiceType::Input;
			break;
		case ServiceType::SessionControl:
			typeProtoValue = ::tvregistrationservice::ServiceType::SessionControl;
			break;
		case ServiceType::SessionStatus:
			typeProtoValue = ::tvregistrationservice::ServiceType::SessionStatus;
			break;
		case ServiceType::ImageNotification:
			typeProtoValue = ::tvregistrationservice::ServiceType::ImageNotification;
			break;
		case ServiceType::AccessControlIn:
			typeProtoValue = ::tvregistrationservice::ServiceType::AccessControlIn;
			break;
		case ServiceType::AccessControlOut:
			typeProtoValue = ::tvregistrationservice::ServiceType::AccessControlOut;
			break;
		case ServiceType::InstantSupport:
			typeProtoValue = ::tvregistrationservice::ServiceType::InstantSupport;
			break;
		case ServiceType::ViewGeometry:
			typeProtoValue = ::tvregistrationservice::ServiceType::ViewGeometry;
			break;
		case ServiceType::InstantSupportNotification:
			typeProtoValue = ::tvregistrationservice::ServiceType::InstantSupportNotification;
			break;
		case ServiceType::ChatIn:
			typeProtoValue = ::tvregistrationservice::ServiceType::ChatIn;
			break;
		case ServiceType::ChatOut:
			typeProtoValue = ::tvregistrationservice::ServiceType::ChatOut;
			break;
		case ServiceType::ConnectionConfirmationRequest:
			typeProtoValue = ::tvregistrationservice::ServiceType::ConnectionConfirmationRequest;
			break;
		case ServiceType::ConnectionConfirmationResponse:
			typeProtoValue = ::tvregistrationservice::ServiceType::ConnectionConfirmationResponse;
			break;
		default:

			break;
	}

	if (typeProtoValue == ::tvregistrationservice::ServiceType::Unknown)
	{
		returnValue.errorMessage = TvServiceBase::ErrorMessage_InvalidInputParameter;
		return returnValue;
	}

	request.set_type(typeProtoValue);

	request.set_location(location);

	::tvregistrationservice::RegisterResponse response{};

	::grpc::Status status = m_stub->Register(&context, request, &response);

	if (status.ok())
	{
		returnValue = CallStatus{CallState::Ok};
	}
	else
	{
		returnValue.errorMessage = status.error_message();
	}

	return returnValue;
}

} // namespace RegistrationService

} // namespace TVRemoteScreenSDKCommunication